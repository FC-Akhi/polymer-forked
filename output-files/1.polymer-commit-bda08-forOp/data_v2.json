{
    "processStmt(clast_root *rootStmt)": {
        "1": {
            "Input": "for (t1=0;t1<=1;t1++) {\n  for (t2=0;t2<=1;t2++) {\n    for (t3=0;t3<=1;t3++) {\n      for (t4=32*t1;t4<=32*t1+31;t4++) {\n        for (t5=32*t3;t5<=32*t3+31;t5++) {\n          for (t6=32*t2;t6<=32*t2+31;t6++) {\n            S0(t4, t6, t5)\n          }\n        }\n      }\n    }\n  }\n}\n"
        },
        "initializeFuncOpInterface()": {
            "oslValueTable": {
                "<block argument> of type 'index' at index: 0": [
                    "i2",
                    "i1",
                    "i0"
                ],
                "%2 = memref.alloc() : memref<64x64xf32>": [
                    "A3"
                ],
                "%1 = memref.alloc() : memref<64x64xf32>": [
                    "A2"
                ],
                "%0 = memref.alloc() : memref<64x64xf32>": [
                    "A1"
                ]
            },
            "getSourceFuncOp()": {
                "sourceFuncName": "matmul",
                "sourceFuncOp": "func @matmul() {\n  %0 = memref.alloc() : memref<64x64xf32>\n  %1 = memref.alloc() : memref<64x64xf32>\n  %2 = memref.alloc() : memref<64x64xf32>\n  affine.for %arg0 = 0 to 64 {\n    affine.for %arg1 = 0 to 64 {\n      affine.for %arg2 = 0 to 64 {\n        call @S0(%arg0, %arg1, %2, %arg2, %1, %0) : (index, index, memref<64x64xf32>, index, memref<64x64xf32>, memref<64x64xf32>) -> ()\n      }\n    }\n  }\n  return\n}"
            },
            "FuncOp class or Ops: object instantiation needs input": {
                "sourceFuncOp.getLoc()": "loc(\"test/archive/PlutoTransform/matmul.mlir\":5:1)",
                "function name": [
                    "matmul_opt"
                ],
                "sourceFuncOp.getType()": [
                    "() -> ()"
                ]
            }
        },
        "New funcOp after initializeFuncOpInterface() processes": "func @matmul_opt() {\n  return\n}",
        "initializeSymbolTable()": {
            "oslSymbolTable": {
                "A1": [
                    "%0 = memref.alloc() : memref<64x64xf32>"
                ],
                "A2": [
                    "%1 = memref.alloc() : memref<64x64xf32>"
                ],
                "A3": [
                    "%2 = memref.alloc() : memref<64x64xf32>"
                ],
                "i0": [
                    "<block argument> of type 'index' at index: 0"
                ],
                "i1": [
                    "<block argument> of type 'index' at index: 0"
                ],
                "i2": [
                    "<block argument> of type 'index' at index: 0"
                ]
            },
            "initializeSymbol(mlir::Value val)": {
                "defOp": [
                    "%0 = memref.alloc() : memref<64x64xf32>",
                    "%1 = memref.alloc() : memref<64x64xf32>",
                    "%2 = memref.alloc() : memref<64x64xf32>"
                ],
                "parentOp": [
                    "func @matmul() {\n  %0 = memref.alloc() : memref<64x64xf32>\n  %1 = memref.alloc() : memref<64x64xf32>\n  %2 = memref.alloc() : memref<64x64xf32>\n  affine.for %arg0 = 0 to 64 {\n    affine.for %arg1 = 0 to 64 {\n      affine.for %arg2 = 0 to 64 {\n        call @S0(%arg0, %arg1, %2, %arg2, %1, %0) : (index, index, memref<64x64xf32>, index, memref<64x64xf32>, memref<64x64xf32>) -> ()\n      }\n    }\n  }\n  return\n}",
                    "func @matmul() {\n  %0 = memref.alloc() : memref<64x64xf32>\n  %1 = memref.alloc() : memref<64x64xf32>\n  %2 = memref.alloc() : memref<64x64xf32>\n  affine.for %arg0 = 0 to 64 {\n    affine.for %arg1 = 0 to 64 {\n      affine.for %arg2 = 0 to 64 {\n        call @S0(%arg0, %arg1, %2, %arg2, %1, %0) : (index, index, memref<64x64xf32>, index, memref<64x64xf32>, memref<64x64xf32>) -> ()\n      }\n    }\n  }\n  return\n}",
                    "func @matmul() {\n  %0 = memref.alloc() : memref<64x64xf32>\n  %1 = memref.alloc() : memref<64x64xf32>\n  %2 = memref.alloc() : memref<64x64xf32>\n  affine.for %arg0 = 0 to 64 {\n    affine.for %arg1 = 0 to 64 {\n      affine.for %arg2 = 0 to 64 {\n        call @S0(%arg0, %arg1, %2, %arg2, %1, %0) : (index, index, memref<64x64xf32>, index, memref<64x64xf32>, memref<64x64xf32>) -> ()\n      }\n    }\n  }\n  return\n}"
                ],
                "func": [
                    "func @matmul_opt() {\n  %0 = memref.alloc() : memref<64x64xf32>\n  %c0 = arith.constant 0 : index\n  return\n}",
                    "func @matmul_opt() {\n  %0 = memref.alloc() : memref<64x64xf32>\n  %1 = memref.alloc() : memref<64x64xf32>\n  %c0 = arith.constant 0 : index\n  return\n}",
                    "func @matmul_opt() {\n  %0 = memref.alloc() : memref<64x64xf32>\n  %1 = memref.alloc() : memref<64x64xf32>\n  %2 = memref.alloc() : memref<64x64xf32>\n  %c0 = arith.constant 0 : index\n  return\n}"
                ]
            },
            "symbolTable": {
                "zero": [
                    "%c0 = arith.constant 0 : index"
                ],
                "A1": [
                    "%2 = memref.alloc() : memref<64x64xf32>"
                ],
                "A2": [
                    "%1 = memref.alloc() : memref<64x64xf32>"
                ],
                "A3": [
                    "%0 = memref.alloc() : memref<64x64xf32>"
                ]
            }
        },
        "New funcOp after initializeSymbolTable() processes": "func @matmul_opt() {\n  %0 = memref.alloc() : memref<64x64xf32>\n  %1 = memref.alloc() : memref<64x64xf32>\n  %2 = memref.alloc() : memref<64x64xf32>\n  %c0 = arith.constant 0 : index\n  return\n}",
        "symbolTable": {
            "zero": [
                "%c0 = arith.constant 0 : index"
            ],
            "A1": [
                "%2 = memref.alloc() : memref<64x64xf32>"
            ],
            "A2": [
                "%1 = memref.alloc() : memref<64x64xf32>"
            ],
            "A3": [
                "%0 = memref.alloc() : memref<64x64xf32>"
            ]
        }
    },
    "processStmt(clast_for *forStmt)": {
        "2": {
            "Input": "for (t1=0;t1<=1;t1++) {\n  for (t2=0;t2<=1;t2++) {\n    for (t3=0;t3<=1;t3++) {\n      for (t4=32*t1;t4<=32*t1+31;t4++) {\n        for (t5=32*t3;t5<=32*t3+31;t5++) {\n          for (t6=32*t2;t6<=32*t2+31;t6++) {\n            S0(t4, t6, t5)\n          }\n        }\n      }\n    }\n  }\n}\n",
            "Loop Bound 0": {
                "getAffineLoopBound()": {
                    "Some Inputs": "forStmt->LB, lbOperands, lbMap or forStmt->UB, ubOperands, ubMap",
                    "processClastLoopBound()": {
                        "process(clast_reduction *expr)": {
                            "process(clast_expr *expr)": {
                                "process(clast_term *expr)": {
                                    "expr": "0",
                                    "expr->val": 0
                                }
                            }
                        }
                    },
                    "after processClastLoopBound()": {
                        "boundExprs": "Affine Expression after processClastLoopBound(): 0"
                    },
                    "builder.dimNames.size": 0,
                    "builder.symbolNames.size": 0
                }
            },
            "Loop Bound 1": {
                "getAffineLoopBound()": {
                    "Some Inputs": "forStmt->LB, lbOperands, lbMap or forStmt->UB, ubOperands, ubMap",
                    "processClastLoopBound()": {
                        "process(clast_reduction *expr)": {
                            "process(clast_expr *expr)": {
                                "process(clast_term *expr)": {
                                    "expr": "1",
                                    "expr->val": 1
                                }
                            }
                        }
                    },
                    "after processClastLoopBound()": {
                        "boundExprs": "Affine Expression after processClastLoopBound(): 2"
                    },
                    "builder.dimNames.size": 0,
                    "builder.symbolNames.size": 0
                }
            },
            "forOp after IR gen": "affine.for %arg0 = 0 to 2 {\n}"
        },
        "3": {
            "Input": "for (t2=0;t2<=1;t2++) {\n  for (t3=0;t3<=1;t3++) {\n    for (t4=32*t1;t4<=32*t1+31;t4++) {\n      for (t5=32*t3;t5<=32*t3+31;t5++) {\n        for (t6=32*t2;t6<=32*t2+31;t6++) {\n          S0(t4, t6, t5)\n        }\n      }\n    }\n  }\n}\n",
            "Loop Bound 0": {
                "getAffineLoopBound()": {
                    "Some Inputs": "forStmt->LB, lbOperands, lbMap or forStmt->UB, ubOperands, ubMap",
                    "processClastLoopBound()": {
                        "process(clast_reduction *expr)": {
                            "process(clast_expr *expr)": {
                                "process(clast_term *expr)": {
                                    "expr": "0",
                                    "expr->val": 0
                                }
                            }
                        }
                    },
                    "after processClastLoopBound()": {
                        "boundExprs": "Affine Expression after processClastLoopBound(): 0"
                    },
                    "builder.dimNames.size": 0,
                    "builder.symbolNames.size": 0
                }
            },
            "Loop Bound 1": {
                "getAffineLoopBound()": {
                    "Some Inputs": "forStmt->LB, lbOperands, lbMap or forStmt->UB, ubOperands, ubMap",
                    "processClastLoopBound()": {
                        "process(clast_reduction *expr)": {
                            "process(clast_expr *expr)": {
                                "process(clast_term *expr)": {
                                    "expr": "1",
                                    "expr->val": 1
                                }
                            }
                        }
                    },
                    "after processClastLoopBound()": {
                        "boundExprs": "Affine Expression after processClastLoopBound(): 2"
                    },
                    "builder.dimNames.size": 0,
                    "builder.symbolNames.size": 0
                }
            },
            "forOp after IR gen": "affine.for %arg1 = 0 to 2 {\n}"
        },
        "4": {
            "Input": "for (t3=0;t3<=1;t3++) {\n  for (t4=32*t1;t4<=32*t1+31;t4++) {\n    for (t5=32*t3;t5<=32*t3+31;t5++) {\n      for (t6=32*t2;t6<=32*t2+31;t6++) {\n        S0(t4, t6, t5)\n      }\n    }\n  }\n}\n",
            "Loop Bound 0": {
                "getAffineLoopBound()": {
                    "Some Inputs": "forStmt->LB, lbOperands, lbMap or forStmt->UB, ubOperands, ubMap",
                    "processClastLoopBound()": {
                        "process(clast_reduction *expr)": {
                            "process(clast_expr *expr)": {
                                "process(clast_term *expr)": {
                                    "expr": "0",
                                    "expr->val": 0
                                }
                            }
                        }
                    },
                    "after processClastLoopBound()": {
                        "boundExprs": "Affine Expression after processClastLoopBound(): 0"
                    },
                    "builder.dimNames.size": 0,
                    "builder.symbolNames.size": 0
                }
            },
            "Loop Bound 1": {
                "getAffineLoopBound()": {
                    "Some Inputs": "forStmt->LB, lbOperands, lbMap or forStmt->UB, ubOperands, ubMap",
                    "processClastLoopBound()": {
                        "process(clast_reduction *expr)": {
                            "process(clast_expr *expr)": {
                                "process(clast_term *expr)": {
                                    "expr": "1",
                                    "expr->val": 1
                                }
                            }
                        }
                    },
                    "after processClastLoopBound()": {
                        "boundExprs": "Affine Expression after processClastLoopBound(): 2"
                    },
                    "builder.dimNames.size": 0,
                    "builder.symbolNames.size": 0
                }
            },
            "forOp after IR gen": "affine.for %arg2 = 0 to 2 {\n}"
        },
        "5": {
            "Input": "for (t4=32*t1;t4<=32*t1+31;t4++) {\n  for (t5=32*t3;t5<=32*t3+31;t5++) {\n    for (t6=32*t2;t6<=32*t2+31;t6++) {\n      S0(t4, t6, t5)\n    }\n  }\n}\n",
            "Loop Bound 32*t1": {
                "getAffineLoopBound()": {
                    "Some Inputs": "forStmt->LB, lbOperands, lbMap or forStmt->UB, ubOperands, ubMap",
                    "processClastLoopBound()": {
                        "process(clast_reduction *expr)": {
                            "expr": "32*t1",
                            "expr->n": "1",
                            "expr->elts[0]": "32*t1",
                            "process(clast_expr *expr)": {
                                "process(clast_term *expr)": {
                                    "expr": "32*t1",
                                    "expr->val": 32,
                                    "expr->var": "t1",
                                    "process(clast_expr *expr)": {
                                        "process(clast_name *expr)": {
                                            "expr": "t1",
                                            "expr->name": "t1",
                                            "symbolTable-before-checking-for-expr->name-in-it": {
                                                "zero": "%c0 = arith.constant 0 : index",
                                                "A1": "%2 = memref.alloc() : memref<64x64xf32>",
                                                "A2": "%1 = memref.alloc() : memref<64x64xf32>",
                                                "A3": "%0 = memref.alloc() : memref<64x64xf32>",
                                                "t1": "<block argument> of type 'index' at index: 0",
                                                "t2": "<block argument> of type 'index' at index: 0",
                                                "t3": "<block argument> of type 'index' at index: 0"
                                            },
                                            "dimNames-after-checking": {
                                                "t1": 0
                                            },
                                            "valueMap-after-checking": {
                                                "<block argument> of type 'index' at index: 0": "t1"
                                            },
                                            "symbolTable-after-checking": {
                                                "zero": "%c0 = arith.constant 0 : index",
                                                "A1": "%2 = memref.alloc() : memref<64x64xf32>",
                                                "A2": "%1 = memref.alloc() : memref<64x64xf32>",
                                                "A3": "%0 = memref.alloc() : memref<64x64xf32>",
                                                "t1": "<block argument> of type 'index' at index: 0",
                                                "t2": "<block argument> of type 'index' at index: 0",
                                                "t3": "<block argument> of type 'index' at index: 0"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "after processClastLoopBound()": {
                        "boundExprs": "Affine Expression after processClastLoopBound(): d0 * 32"
                    },
                    "builder.dimNames": {
                        "t1": 0
                    },
                    "builder.dimNames.size": 1,
                    "builder.symbolNames.size": 0
                }
            },
            "Loop Bound 32*t1+31": {
                "getAffineLoopBound()": {
                    "Some Inputs": "forStmt->LB, lbOperands, lbMap or forStmt->UB, ubOperands, ubMap",
                    "processClastLoopBound()": {
                        "process(clast_reduction *expr)": {
                            "expr": "32*t1+31",
                            "process(clast_expr *expr)": {
                                "process(clast_term *expr)": {
                                    "expr": "31",
                                    "expr->val": 31,
                                    "expr->var": "t1",
                                    "process(clast_expr *expr)": {
                                        "process(clast_name *expr)": {
                                            "expr": "t1",
                                            "expr->name": "t1",
                                            "symbolTable-before-checking-for-expr->name-in-it": {
                                                "zero": "%c0 = arith.constant 0 : index",
                                                "A1": "%2 = memref.alloc() : memref<64x64xf32>",
                                                "A2": "%1 = memref.alloc() : memref<64x64xf32>",
                                                "A3": "%0 = memref.alloc() : memref<64x64xf32>",
                                                "t1": "<block argument> of type 'index' at index: 0",
                                                "t2": "<block argument> of type 'index' at index: 0",
                                                "t3": "<block argument> of type 'index' at index: 0"
                                            },
                                            "dimNames-after-checking": {
                                                "t1": 0
                                            },
                                            "valueMap-after-checking": {
                                                "<block argument> of type 'index' at index: 0": "t1"
                                            },
                                            "symbolTable-after-checking": {
                                                "zero": "%c0 = arith.constant 0 : index",
                                                "A1": "%2 = memref.alloc() : memref<64x64xf32>",
                                                "A2": "%1 = memref.alloc() : memref<64x64xf32>",
                                                "A3": "%0 = memref.alloc() : memref<64x64xf32>",
                                                "t1": "<block argument> of type 'index' at index: 0",
                                                "t2": "<block argument> of type 'index' at index: 0",
                                                "t3": "<block argument> of type 'index' at index: 0"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "after processClastLoopBound()": {
                        "boundExprs": "Affine Expression after processClastLoopBound(): d0 * 32 + 32"
                    },
                    "builder.dimNames": {
                        "t1": 0
                    },
                    "builder.dimNames.size": 1,
                    "builder.symbolNames.size": 0
                }
            },
            "After getAffineLoopBound() operation": {
                "Operands": {
                    "lbOperands": [
                        "<block argument> of type 'index' at index: 0"
                    ],
                    "ubOperands": [
                        "<block argument> of type 'index' at index: 0"
                    ]
                }
            },
            "forOp after IR gen": "affine.for %arg3 = affine_map<(d0) -> (d0 * 32)>(%arg0) to affine_map<(d0) -> (d0 * 32 + 32)>(%arg0) {\n}"
        },
        "6": {
            "Input": "for (t5=32*t3;t5<=32*t3+31;t5++) {\n  for (t6=32*t2;t6<=32*t2+31;t6++) {\n    S0(t4, t6, t5)\n  }\n}\n",
            "Loop Bound 32*t3": {
                "getAffineLoopBound()": {
                    "Some Inputs": "forStmt->LB, lbOperands, lbMap or forStmt->UB, ubOperands, ubMap",
                    "processClastLoopBound()": {
                        "process(clast_reduction *expr)": {
                            "expr": "32*t3",
                            "expr->n": "1",
                            "expr->elts[0]": "32*t3",
                            "process(clast_expr *expr)": {
                                "process(clast_term *expr)": {
                                    "expr": "32*t3",
                                    "expr->val": 32,
                                    "expr->var": "t3",
                                    "process(clast_expr *expr)": {
                                        "process(clast_name *expr)": {
                                            "expr": "t3",
                                            "expr->name": "t3",
                                            "symbolTable-before-checking-for-expr->name-in-it": {
                                                "zero": "%c0 = arith.constant 0 : index",
                                                "A1": "%2 = memref.alloc() : memref<64x64xf32>",
                                                "A2": "%1 = memref.alloc() : memref<64x64xf32>",
                                                "A3": "%0 = memref.alloc() : memref<64x64xf32>",
                                                "t1": "<block argument> of type 'index' at index: 0",
                                                "t2": "<block argument> of type 'index' at index: 0",
                                                "t3": "<block argument> of type 'index' at index: 0",
                                                "t4": "<block argument> of type 'index' at index: 0"
                                            },
                                            "dimNames-after-checking": {
                                                "t3": 0
                                            },
                                            "valueMap-after-checking": {
                                                "<block argument> of type 'index' at index: 0": "t3"
                                            },
                                            "symbolTable-after-checking": {
                                                "zero": "%c0 = arith.constant 0 : index",
                                                "A1": "%2 = memref.alloc() : memref<64x64xf32>",
                                                "A2": "%1 = memref.alloc() : memref<64x64xf32>",
                                                "A3": "%0 = memref.alloc() : memref<64x64xf32>",
                                                "t1": "<block argument> of type 'index' at index: 0",
                                                "t2": "<block argument> of type 'index' at index: 0",
                                                "t3": "<block argument> of type 'index' at index: 0",
                                                "t4": "<block argument> of type 'index' at index: 0"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "after processClastLoopBound()": {
                        "boundExprs": "Affine Expression after processClastLoopBound(): d0 * 32"
                    },
                    "builder.dimNames": {
                        "t3": 0
                    },
                    "builder.dimNames.size": 1,
                    "builder.symbolNames.size": 0
                }
            },
            "Loop Bound 32*t3+31": {
                "getAffineLoopBound()": {
                    "Some Inputs": "forStmt->LB, lbOperands, lbMap or forStmt->UB, ubOperands, ubMap",
                    "processClastLoopBound()": {
                        "process(clast_reduction *expr)": {
                            "expr": "32*t3+31",
                            "process(clast_expr *expr)": {
                                "process(clast_term *expr)": {
                                    "expr": "31",
                                    "expr->val": 31,
                                    "expr->var": "t3",
                                    "process(clast_expr *expr)": {
                                        "process(clast_name *expr)": {
                                            "expr": "t3",
                                            "expr->name": "t3",
                                            "symbolTable-before-checking-for-expr->name-in-it": {
                                                "zero": "%c0 = arith.constant 0 : index",
                                                "A1": "%2 = memref.alloc() : memref<64x64xf32>",
                                                "A2": "%1 = memref.alloc() : memref<64x64xf32>",
                                                "A3": "%0 = memref.alloc() : memref<64x64xf32>",
                                                "t1": "<block argument> of type 'index' at index: 0",
                                                "t2": "<block argument> of type 'index' at index: 0",
                                                "t3": "<block argument> of type 'index' at index: 0",
                                                "t4": "<block argument> of type 'index' at index: 0"
                                            },
                                            "dimNames-after-checking": {
                                                "t3": 0
                                            },
                                            "valueMap-after-checking": {
                                                "<block argument> of type 'index' at index: 0": "t3"
                                            },
                                            "symbolTable-after-checking": {
                                                "zero": "%c0 = arith.constant 0 : index",
                                                "A1": "%2 = memref.alloc() : memref<64x64xf32>",
                                                "A2": "%1 = memref.alloc() : memref<64x64xf32>",
                                                "A3": "%0 = memref.alloc() : memref<64x64xf32>",
                                                "t1": "<block argument> of type 'index' at index: 0",
                                                "t2": "<block argument> of type 'index' at index: 0",
                                                "t3": "<block argument> of type 'index' at index: 0",
                                                "t4": "<block argument> of type 'index' at index: 0"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "after processClastLoopBound()": {
                        "boundExprs": "Affine Expression after processClastLoopBound(): d0 * 32 + 32"
                    },
                    "builder.dimNames": {
                        "t3": 0
                    },
                    "builder.dimNames.size": 1,
                    "builder.symbolNames.size": 0
                }
            },
            "After getAffineLoopBound() operation": {
                "Operands": {
                    "lbOperands": [
                        "<block argument> of type 'index' at index: 0"
                    ],
                    "ubOperands": [
                        "<block argument> of type 'index' at index: 0"
                    ]
                }
            },
            "forOp after IR gen": "affine.for %arg4 = affine_map<(d0) -> (d0 * 32)>(%arg2) to affine_map<(d0) -> (d0 * 32 + 32)>(%arg2) {\n}"
        },
        "7": {
            "Input": "for (t6=32*t2;t6<=32*t2+31;t6++) {\n  S0(t4, t6, t5)\n}\n",
            "Loop Bound 32*t2": {
                "getAffineLoopBound()": {
                    "Some Inputs": "forStmt->LB, lbOperands, lbMap or forStmt->UB, ubOperands, ubMap",
                    "processClastLoopBound()": {
                        "process(clast_reduction *expr)": {
                            "expr": "32*t2",
                            "expr->n": "1",
                            "expr->elts[0]": "32*t2",
                            "process(clast_expr *expr)": {
                                "process(clast_term *expr)": {
                                    "expr": "32*t2",
                                    "expr->val": 32,
                                    "expr->var": "t2",
                                    "process(clast_expr *expr)": {
                                        "process(clast_name *expr)": {
                                            "expr": "t2",
                                            "expr->name": "t2",
                                            "symbolTable-before-checking-for-expr->name-in-it": {
                                                "zero": "%c0 = arith.constant 0 : index",
                                                "A1": "%2 = memref.alloc() : memref<64x64xf32>",
                                                "A2": "%1 = memref.alloc() : memref<64x64xf32>",
                                                "A3": "%0 = memref.alloc() : memref<64x64xf32>",
                                                "t1": "<block argument> of type 'index' at index: 0",
                                                "t2": "<block argument> of type 'index' at index: 0",
                                                "t3": "<block argument> of type 'index' at index: 0",
                                                "t4": "<block argument> of type 'index' at index: 0",
                                                "t5": "<block argument> of type 'index' at index: 0"
                                            },
                                            "dimNames-after-checking": {
                                                "t2": 0
                                            },
                                            "valueMap-after-checking": {
                                                "<block argument> of type 'index' at index: 0": "t2"
                                            },
                                            "symbolTable-after-checking": {
                                                "zero": "%c0 = arith.constant 0 : index",
                                                "A1": "%2 = memref.alloc() : memref<64x64xf32>",
                                                "A2": "%1 = memref.alloc() : memref<64x64xf32>",
                                                "A3": "%0 = memref.alloc() : memref<64x64xf32>",
                                                "t1": "<block argument> of type 'index' at index: 0",
                                                "t2": "<block argument> of type 'index' at index: 0",
                                                "t3": "<block argument> of type 'index' at index: 0",
                                                "t4": "<block argument> of type 'index' at index: 0",
                                                "t5": "<block argument> of type 'index' at index: 0"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "after processClastLoopBound()": {
                        "boundExprs": "Affine Expression after processClastLoopBound(): d0 * 32"
                    },
                    "builder.dimNames": {
                        "t2": 0
                    },
                    "builder.dimNames.size": 1,
                    "builder.symbolNames.size": 0
                }
            },
            "Loop Bound 32*t2+31": {
                "getAffineLoopBound()": {
                    "Some Inputs": "forStmt->LB, lbOperands, lbMap or forStmt->UB, ubOperands, ubMap",
                    "processClastLoopBound()": {
                        "process(clast_reduction *expr)": {
                            "expr": "32*t2+31",
                            "process(clast_expr *expr)": {
                                "process(clast_term *expr)": {
                                    "expr": "31",
                                    "expr->val": 31,
                                    "expr->var": "t2",
                                    "process(clast_expr *expr)": {
                                        "process(clast_name *expr)": {
                                            "expr": "t2",
                                            "expr->name": "t2",
                                            "symbolTable-before-checking-for-expr->name-in-it": {
                                                "zero": "%c0 = arith.constant 0 : index",
                                                "A1": "%2 = memref.alloc() : memref<64x64xf32>",
                                                "A2": "%1 = memref.alloc() : memref<64x64xf32>",
                                                "A3": "%0 = memref.alloc() : memref<64x64xf32>",
                                                "t1": "<block argument> of type 'index' at index: 0",
                                                "t2": "<block argument> of type 'index' at index: 0",
                                                "t3": "<block argument> of type 'index' at index: 0",
                                                "t4": "<block argument> of type 'index' at index: 0",
                                                "t5": "<block argument> of type 'index' at index: 0"
                                            },
                                            "dimNames-after-checking": {
                                                "t2": 0
                                            },
                                            "valueMap-after-checking": {
                                                "<block argument> of type 'index' at index: 0": "t2"
                                            },
                                            "symbolTable-after-checking": {
                                                "zero": "%c0 = arith.constant 0 : index",
                                                "A1": "%2 = memref.alloc() : memref<64x64xf32>",
                                                "A2": "%1 = memref.alloc() : memref<64x64xf32>",
                                                "A3": "%0 = memref.alloc() : memref<64x64xf32>",
                                                "t1": "<block argument> of type 'index' at index: 0",
                                                "t2": "<block argument> of type 'index' at index: 0",
                                                "t3": "<block argument> of type 'index' at index: 0",
                                                "t4": "<block argument> of type 'index' at index: 0",
                                                "t5": "<block argument> of type 'index' at index: 0"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "after processClastLoopBound()": {
                        "boundExprs": "Affine Expression after processClastLoopBound(): d0 * 32 + 32"
                    },
                    "builder.dimNames": {
                        "t2": 0
                    },
                    "builder.dimNames.size": 1,
                    "builder.symbolNames.size": 0
                }
            },
            "After getAffineLoopBound() operation": {
                "Operands": {
                    "lbOperands": [
                        "<block argument> of type 'index' at index: 0"
                    ],
                    "ubOperands": [
                        "<block argument> of type 'index' at index: 0"
                    ]
                }
            },
            "forOp after IR gen": "affine.for %arg5 = affine_map<(d0) -> (d0 * 32)>(%arg1) to affine_map<(d0) -> (d0 * 32 + 32)>(%arg1) {\n}"
        },
        "8": {
            "Loop Bound 32*t2+31": {
                "getAffineLoopBound()": {
                    "processClastLoopBound()": {
                        "process(clast_reduction *expr)": {
                            "expr": "t5",
                            "expr->n": "1",
                            "expr->elts[0]": "t5",
                            "process(clast_expr *expr)": {
                                "process(clast_term *expr)": {
                                    "expr": "t5",
                                    "expr->val": 1,
                                    "expr->var": "t5",
                                    "process(clast_expr *expr)": {
                                        "process(clast_name *expr)": {
                                            "expr": "t5",
                                            "expr->name": "t5",
                                            "symbolTable-before-checking-for-expr->name-in-it": {
                                                "zero": "%c0 = arith.constant 0 : index",
                                                "A1": "%2 = memref.alloc() : memref<64x64xf32>",
                                                "A2": "%1 = memref.alloc() : memref<64x64xf32>",
                                                "A3": "%0 = memref.alloc() : memref<64x64xf32>",
                                                "t1": "<block argument> of type 'index' at index: 0",
                                                "t2": "<block argument> of type 'index' at index: 0",
                                                "t3": "<block argument> of type 'index' at index: 0",
                                                "t4": "<block argument> of type 'index' at index: 0",
                                                "t5": "<block argument> of type 'index' at index: 0",
                                                "t6": "<block argument> of type 'index' at index: 0"
                                            },
                                            "dimNames-after-checking": {
                                                "t4": 0,
                                                "t6": 0,
                                                "t5": 0
                                            },
                                            "valueMap-after-checking": {
                                                "<block argument> of type 'index' at index: 0": "t5"
                                            },
                                            "symbolTable-after-checking": {
                                                "zero": "%c0 = arith.constant 0 : index",
                                                "A1": "%2 = memref.alloc() : memref<64x64xf32>",
                                                "A2": "%1 = memref.alloc() : memref<64x64xf32>",
                                                "A3": "%0 = memref.alloc() : memref<64x64xf32>",
                                                "t1": "<block argument> of type 'index' at index: 0",
                                                "t2": "<block argument> of type 'index' at index: 0",
                                                "t3": "<block argument> of type 'index' at index: 0",
                                                "t4": "<block argument> of type 'index' at index: 0",
                                                "t5": "<block argument> of type 'index' at index: 0",
                                                "t6": "<block argument> of type 'index' at index: 0"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}